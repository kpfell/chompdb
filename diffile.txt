diff --git core/src/main/scala/chompdb/server/Chomp.scala core/src/main/scala/chompdb/server/Chomp.scala
index 40ba7ae..b27a4a9 100644
--- core/src/main/scala/chompdb/server/Chomp.scala
+++ core/src/main/scala/chompdb/server/Chomp.scala
@@ -35,11 +35,11 @@ object Chomp {
 
       val blobDatabase = chomp.databases
         .find { db => db.catalog.name == catalog && db.name == database }
-        .getOrElse { throw new DatabaseNotFoundException("Database $database not found.") }
+        .getOrElse { throw new DatabaseNotFoundException(s"Database $database not found.") }
 
       val numShards = chomp.numShardsPerVersion getOrElse (
         (blobDatabase, version),
-        throw new ShardsNotFoundException("Shards for database $blobDatabase.name version $version not found.")
+        throw new ShardsNotFoundException(s"Shards for database $blobDatabase.name version $version not found.")
       )
 
       val result = parSeq(ids) map { id => 
@@ -91,6 +91,8 @@ abstract class Chomp extends SlapChop {
   // Maximum number of times the Chomp will attempt to download
   // a DatabaseVersionShard
   val maxDownloadRetries: Int
+  // Amount of time to wait before reattempting a database version download
+  val databaseDownloadRetryDelay: Duration
   // ScheduledExecutorService for scheduling recurring database updates,
   // network status updates, etc.
   val executor: ScheduledExecutorService
@@ -142,11 +144,19 @@ abstract class Chomp extends SlapChop {
   def run() {
     hashRing.initialize(nodes keySet)
 
+    purgeInconsistentShards()
+
     for (database <- databases) {
+      val localVersions = localDB(database).versionedStore.versions
+
+      if (localVersions.length != 0) {
+        val latestVersion = localVersions.head
+        downloadDatabaseVersion(database, latestVersion)
+      }
+
       scheduleDatabaseUpdate(databaseUpdateFreq, database)
     }
 
-    purgeInconsistentShards()
     initializeAvailableShards()
     initializeServingVersions()
     initializeNumShardsPerVersion()
@@ -155,77 +165,191 @@ abstract class Chomp extends SlapChop {
     scheduleServingVersions(servingVersionsFreq)
   }
 
-  def downloadDatabaseVersion(database: Database, version: Long) {
-    val remoteDir = database.versionedStore.versionPath(version)
-    val remoteVersionMarker = database.versionedStore.versionMarker(version)
+//   def resumeDatabaseVersionDownload(database: Database, version: Long) {
+//     val remoteDir = database.versionedStore.versionPath(version)
+//     val remoteVersionMarker = database.versionedStore.versionMarker(version)
 
-    // TODO: This "fails" silently if the version marker does not exist
-    if (remoteVersionMarker.exists) {
-      val localDB = Chomp.this.localDB(database)
+//     if (remoteVersionMarker.exists) {
+//       val localDir = localDB(database).versionedStore.versionPath(version)
 
-      // TODO: What does createVersion do if there already exists a version there?
-      val localDir = localDB.versionedStore.createVersion(version)
+//       val remoteFiles = remoteDir.listFiles
+//       val localFiles = localDir.listFiles
 
-      // TODO: This "fails" silently if the number of max retries is reached.
-      localDB.versionedStore.deleteIncompleteShards(version)
+//       val basenamesToDownload = remoteFiles
+//         .diff(localFiles)
+//         .map { _.basename }
+//         .filter { basename => (basename forall Character.isDigit) &&
+//           (hashRing.getNodesForShard(basename.toInt) contains localNode)
+//         }
+//         .toSet
 
-      copyShards(remoteDir, localDir, 0) foreach { numRetries => 
-        if (numRetries < maxDownloadRetries) {
-          localDB.versionedStore.deleteIncompleteShards(version)
-          copyShards(remoteDir, localDir, numRetries)
-        }
-        else localDB.versionedStore.deleteIncompleteShards(version)
-      }
+// //////////////////////////////// IN PROGRESS ////////////////////////////////////////////
+//       for (b <- basenamesToDownload) {
+//         copyShardFiles(database, version, b, remoteDir, localDB(database).versionedStore.root)
+//       }
+// /////////////////////////////////////////////////////////////////////////////////////////
+//     }
+//   }
 
-      copyVersionFile(database.versionedStore.versionMarker(version), localDB.versionedStore.root)
-    }
+  def downloadDatabaseVersion(remoteDatabase: Database, version: Long) {
+    val remoteVersion = remoteDatabase.versionedStore.versionPath(version)
+    val remoteVersionMarker = remoteDatabase.versionedStore.versionMarker(version)
 
-    def copyShards(remoteVersionDir: FileSystem#Dir, localVersionDir: FileSystem#Dir, numRetries: Int): Option[Int] = {
-      val remoteBasenamesToDownload = remoteVersionDir
-        .listFiles
-        .map { _.basename }
-        .filter { basename => (basename forall Character.isDigit) && 
-          (hashRing.getNodesForShard(basename.toInt) contains localNode) 
-        }
-        .toSet
+    val localDatabase = localDB(remoteDatabase)
+
+    if (remoteVersionMarker.exists) {
+      val localVersion = localDatabase.versionedStore.versionPath(version)
 
-      for (basename <- remoteBasenamesToDownload) {
-        copyShardFiles(basename, remoteVersionDir, localVersionDir)
+      if (!localVersion.exists) {
+        localDatabase.versionedStore.createVersion(version)
+      } else {
+        localDatabase.versionedStore.deleteIncompleteShards(version)
       }
 
-      def copyShardFiles(basename: String, remoteVersionDir: FileSystem#Dir, localVersionDir: FileSystem#Dir) {
-        val shard = DatabaseVersionShard(database.catalog.name, database.name, version, basename.toInt)
+      val remoteShards = remoteDatabase.versionedStore
+        .shardNumsForVersion(version)
+        .map { shardNum => DatabaseVersionShard(remoteDatabase.catalog.name, remoteDatabase.name, version, shardNum) }
 
-        val blobFile = shard.blobFile(database.versionedStore)
-        copy(blobFile, localVersionDir / blobFile.filename)
+      val localShards = localDatabase.versionedStore
+        .shardNumsForVersion(version)
+        .map { shardNum => DatabaseVersionShard(localDatabase.catalog.name, localDatabase.name, version, shardNum) }
 
-        val indexFile = shard.indexFile(database.versionedStore)
-        copy(indexFile, localVersionDir / indexFile.filename)
+      val remoteShardsToDownload = remoteShards
+        .diff(localShards)
+        .filter { s => hashRing.getNodesForShard(s.shard) contains localNode }
 
-        if (shard.blobFile(localDB(database).versionedStore).exists && shard.indexFile(localDB(database).versionedStore).exists) {
-          Chomp.this.localDB(database).versionedStore.succeedShard(version, basename.toInt)
-        }
+      val name = s"Download $remoteDatabase version $version"
 
-        if (Chomp.this.localDB(database).versionedStore.shardMarker(version, basename.toInt).exists) {
-          addAvailableShard(shard)
+      try retry(name, maxDownloadRetries, databaseDownloadRetryDelay) {
+        for (shard <- remoteShardsToDownload) {
+          copyShard(remoteDatabase, localDatabase, shard)
         }
+      } catch { case e: Exception =>
+        localDatabase.versionedStore.deleteIncompleteShards(version)
       }
+      
+      copy(remoteVersionMarker, localDatabase.versionedStore.versionPath(version) / remoteVersionMarker.filename)
+    }
+  }
 
-      val localBasenames = localVersionDir
-        .listFiles
-        .filter { _.extension == "shard" }
-        .map { _.basename }
-        .toSet
+  def copyShard(remoteDatabase: Database, localDatabase: Database, shard: DatabaseVersionShard) {
+    val localVersionDir = localDatabase.versionedStore.versionPath(shard.version)
 
-      if (remoteBasenamesToDownload == localBasenames) None
-      else Some(numRetries + 1)
+    val remoteBlobFile = shard.blobFile(remoteDatabase.versionedStore)
+    copy(remoteBlobFile, localVersionDir / remoteBlobFile.filename)
+
+    val remoteIndexFile = shard.indexFile(remoteDatabase.versionedStore)
+    copy(remoteIndexFile, localVersionDir / remoteIndexFile.filename)
+
+    if ((shard.blobFile(localDatabase.versionedStore)).exists && shard.indexFile(localDatabase.versionedStore).exists) {
+      localDB(remoteDatabase).versionedStore.succeedShard(shard.version, shard.shard)
     }
 
-    def copyVersionFile(versionRemotePath: FileSystem#File, versionLocalDir: FileSystem#Dir) {
-      copy(versionRemotePath, versionLocalDir / versionRemotePath.filename)
+    if (localDB(localDatabase).versionedStore.shardMarker(shard.version, shard.shard).exists) {
+      addAvailableShard(shard)
     }
   }
 
+  private def retry[T](name: String, nTimes: Int, delay: Duration)(f: => T): T = {
+    var retries = 0
+    var success = false
+    var result = null.asInstanceOf[T]
+
+    while(!success && retries < nTimes) {
+      try {
+        result = f
+        success = true
+      } catch {
+        case e: InterruptedException => {
+          // log.info("Interrupted during %s after %d retries -- aborting." format (name, retries)) 
+          throw e
+        }
+
+        case e: Exception => {
+          retries += 1
+          if (retries == nTimes) {
+            throw e
+          }
+          // log.info("Exception occurred during %s, retrying %d more times: %s" format (name, nTimes-retries, e))
+          Thread.sleep(delay.toMillis)
+        }
+      }
+    }
+
+    result
+  }
+
+  // def downloadDatabaseVersion(database: Database, version: Long) {
+  //   val remoteDir = database.versionedStore.versionPath(version)
+  //   val remoteVersionMarker = database.versionedStore.versionMarker(version)
+
+  //   val localDatabase = localDB(database)
+
+  //   if (remoteVersionMarker.exists) {
+
+  //     // TODO: What does createVersion do if there already exists a version there?
+  //     val localDir = localDatabase.versionedStore.createVersion(version)
+
+  //     // TODO: This "fails" silently if the number of max retries is reached.
+  //     localDatabase.versionedStore.deleteIncompleteShards(version)
+
+  //     copyShards(remoteDir, localDir, 0) foreach { numRetries => 
+  //       if (numRetries < maxDownloadRetries) {
+  //         localDatabase.versionedStore.deleteIncompleteShards(version)
+  //         copyShards(remoteDir, localDir, numRetries)
+  //       }
+  //       else localDatabase.versionedStore.deleteIncompleteShards(version)
+  //     }
+
+  //     copyVersionFile(database.versionedStore.versionMarker(version), localDatabase.versionedStore.root)
+  //   }
+
+  //   def copyShards(remoteVersionDir: FileSystem#Dir, localVersionDir: FileSystem#Dir, numRetries: Int): Option[Int] = {
+  //     val remoteBasenamesToDownload = remoteVersionDir
+  //       .listFiles
+  //       .map { _.basename }
+  //       .filter { basename => (basename forall Character.isDigit) && 
+  //         (hashRing.getNodesForShard(basename.toInt) contains localNode) 
+  //       }
+  //       .toSet
+
+  //     for (basename <- remoteBasenamesToDownload) {
+  //       copyShardFiles(database, version, basename, remoteVersionDir, localVersionDir)
+  //     }
+
+  //     val localBasenames = localVersionDir
+  //       .listFiles
+  //       .filter { _.extension == "shard" }
+  //       .map { _.basename }
+  //       .toSet
+
+  //     if (remoteBasenamesToDownload == localBasenames) None
+  //     else Some(numRetries + 1)
+  //   }
+
+  //   def copyVersionFile(versionRemotePath: FileSystem#File, versionLocalDir: FileSystem#Dir) {
+  //     copy(versionRemotePath, versionLocalDir / versionRemotePath.filename)
+  //   }
+  // }
+
+  // def copyShardFiles(database: Database, version: Long, basename: String, remoteVersionDir: FileSystem#Dir, localVersionDir: FileSystem#Dir) {
+  //   val shard = DatabaseVersionShard(database.catalog.name, database.name, version, basename.toInt)
+
+  //   val blobFile = shard.blobFile(database.versionedStore)
+  //   copy(blobFile, localVersionDir / blobFile.filename)
+
+  //   val indexFile = shard.indexFile(database.versionedStore)
+  //   copy(indexFile, localVersionDir / indexFile.filename)
+
+  //   if (shard.blobFile(localDB(database).versionedStore).exists && shard.indexFile(localDB(database).versionedStore).exists) {
+  //     Chomp.this.localDB(database).versionedStore.succeedShard(version, basename.toInt)
+  //   }
+
+  //   if (Chomp.this.localDB(database).versionedStore.shardMarker(version, basename.toInt).exists) {
+  //     addAvailableShard(shard)
+  //   }
+  // }
+
   private def parMap[T, U](m: Map[T, U]) = {
     val pc = m.par
     val executionContext = ExecutionContext.fromExecutor(executor)
@@ -236,20 +360,20 @@ abstract class Chomp extends SlapChop {
   override def mapReduce[T: TypeTag](catalog: String, database: String, keys: Seq[Long], mapReduce: MapReduce[ByteBuffer, T]) = {
     val blobDatabase = databases
       .find { db => db.catalog.name == catalog && db.name == database }
-      .getOrElse { throw new DatabaseNotFoundException("Database $database not found.") }
+      .getOrElse { throw new DatabaseNotFoundException(s"Database $database not found.") }
 
     val servedVersion = servingVersions getOrElse (
       blobDatabase,
-      throw new DatabaseNotServedException("Database $blobDatabase.name not currently being served.")
+      throw new DatabaseNotServedException(s"Database $blobDatabase.name not currently being served.")
     )
 
     val version = servedVersion getOrElse (
-      throw new VersionNotFoundException("Shards for database $blobDatabase.name version $version not found.")
+      throw new VersionNotFoundException(s"Version for $blobDatabase.name not found.")
     )
 
     val numShards = numShardsPerVersion getOrElse (
       (blobDatabase, version),
-      throw new ShardsNotFoundException("Shards for database $blobDatabase.name version $version not found.")
+      throw new ShardsNotFoundException(s"Shards for database $blobDatabase.name version $version not found.")
     )
 
     val keysToNodes = partitionKeys(keys, blobDatabase, version, numShards)
@@ -396,15 +520,38 @@ abstract class Chomp extends SlapChop {
   }
 
   def updateDatabase(database: Database) {
+    val localDatabase = localDB(database)
+
     getNewerVersionNumber(database) foreach { version => 
-      if (!localDB(database).versionedStore.versionExists(version)) {
+      if (!localDatabase.versionedStore.versionExists(version)) {
         downloadDatabaseVersion(database, version)
       }
     }
 
-    localDB(database)
+    val mostRecentVersion: Long = localDatabase
       .versionedStore
-      .cleanup(maxVersions)
+      .mostRecentVersion
+      .getOrElse { throw new VersionNotFoundException(s"No recent version found for $localDatabase.") }
+
+    val latestVersionShardsInNetwork = nodesContent
+      .values
+      .toList
+      .flatten
+      .filter { s => s.version == mostRecentVersion }
+    
+    val shardCounts = latestVersionShardsInNetwork
+      .groupBy { s => s.shard }
+      .map { case (shard, shardList) => shardList.length }
+
+    val numShardsBelowRepFactor = shardCounts
+      .filter { _ < replicationBeforeVersionUpgrade }
+      .size
+
+    if (numShardsBelowRepFactor == 0) {
+      localDatabase
+        .versionedStore
+        .cleanup(maxVersions)
+    }
   }
 
   def updateNodesAlive() {
diff --git core/src/test/scala/chompdb/server/ChompTest.scala core/src/test/scala/chompdb/server/ChompTest.scala
index 87faaeb..5c95c7c 100644
--- core/src/test/scala/chompdb/server/ChompTest.scala
+++ core/src/test/scala/chompdb/server/ChompTest.scala
@@ -60,6 +60,7 @@ class ChompTest extends WordSpec with ShouldMatchers {
     override val replicationBeforeVersionUpgrade = 1
     override val maxVersions = 3
     override val maxDownloadRetries = 3
+    override val databaseDownloadRetryDelay = 10.millisecond
     override val executor = mock(classOf[ScheduledExecutorService])
     override val databaseUpdateFreq = 1.minute
     override val nodesAliveFreq = 1.minute
@@ -197,38 +198,50 @@ class ChompTest extends WordSpec with ShouldMatchers {
     "download appropriate shards for given database version" in {
       val database1Local = chomp.localDB(database1)
 
-      database1Local.versionedStore.versionExists(2L) should be === false
+      database1.versionedStore.versionExists(2L) should be === false
 
       database1.versionedStore.createVersion(2L)
       createEmptyShard(database1.versionedStore, 2L)
       createEmptyShard(database1.versionedStore, 2L)
       database1.versionedStore.succeedVersion(2L, 2)
 
-      chomp.downloadDatabaseVersion(database1, 2L)
-
-      database1Local.versionedStore.versionExists(2L) should be === true      
-
-      val basenames = database1
-        .versionedStore
-        .versionPath(2L)
-        .listFiles
-        .filter { _.basename forall Character.isDigit }
-        .map { f => f.basename }
-        .toSet
+      database1.versionedStore.versionExists(2L) should be === true
 
-      basenames foreach { basename => 
-        if (chomp.hashRing.getNodesForShard(basename.toInt) contains chomp.localNode) {
-          (database1Local.versionedStore.versionPath(2L) / (basename + ".blob")).exists should be === true
-          (database1Local.versionedStore.versionPath(2L) / (basename + ".index")).exists should be === true
-          database1Local.versionedStore.shardMarker(2L, basename.toInt).exists should be === true
-          chomp.availableShards.contains(DatabaseVersionShard(database1.catalog.name, database1.name, 2L, basename.toInt)) should be === true
-        } else {
-          (database1Local.versionedStore.versionPath(2L) / (basename + ".blob")).exists should be === false
-          (database1Local.versionedStore.versionPath(2L) / (basename + ".index")).exists should be === false
-          database1Local.versionedStore.shardMarker(2L, basename.toInt).exists should be === false
-          chomp.availableShards.contains(DatabaseVersionShard(database1.catalog.name, database1.name, 2L, basename.toInt)) should be === false
-        }
-      }
+      database1Local.versionedStore.versionExists(2L) should be === false
+      chomp.downloadDatabaseVersion(database1, 2L)
+      // database1Local.versionedStore.versionExists(2L) should be === true
+
+      // val basenames = database1
+      //   .versionedStore
+      //   .versionPath(2L)
+      //   .listFiles
+      //   .filter { _.basename forall Character.isDigit }
+      //   .map { f => f.basename }
+      //   .toSet
+
+      // basenames foreach { basename => 
+      //   if (chomp.hashRing.getNodesForShard(basename.toInt) contains chomp.localNode) {
+      //     (database1Local.versionedStore.versionPath(2L) / (basename + ".blob")).exists should be === true
+      //     (database1Local.versionedStore.versionPath(2L) / (basename + ".index")).exists should be === true
+      //     database1Local.versionedStore.shardMarker(2L, basename.toInt).exists should be === true
+      //     chomp.availableShards.contains(DatabaseVersionShard(database1.catalog.name, database1.name, 2L, basename.toInt)) should be === true
+      //   } else {
+      //     (database1Local.versionedStore.versionPath(2L) / (basename + ".blob")).exists should be === false
+      //     (database1Local.versionedStore.versionPath(2L) / (basename + ".index")).exists should be === false
+      //     database1Local.versionedStore.shardMarker(2L, basename.toInt).exists should be === false
+      //     chomp.availableShards.contains(DatabaseVersionShard(database1.catalog.name, database1.name, 2L, basename.toInt)) should be === false
+      //   }
+      // }
+
+      (database1Local.versionedStore.versionPath(2L) / (0 + ".blob")).exists should be === true
+      (database1Local.versionedStore.versionPath(2L) / (0 + ".index")).exists should be === true
+      database1Local.versionedStore.shardMarker(2L, 0).exists should be === true
+      chomp.availableShards.contains(DatabaseVersionShard(database1.catalog.name, database1.name, 2L, 0)) should be === true
+    
+      (database1Local.versionedStore.versionPath(2L) / (1 + ".blob")).exists should be === true
+      (database1Local.versionedStore.versionPath(2L) / (1 + ".index")).exists should be === true
+      database1Local.versionedStore.shardMarker(2L, 1).exists should be === true
+      chomp.availableShards.contains(DatabaseVersionShard(database1.catalog.name, database1.name, 2L, 1)) should be === true 
     }
 
     "begin serving a given database version" in {
diff --git core/src/test/scala/chompdb/server/NodeProtocolTest.scala core/src/test/scala/chompdb/server/NodeProtocolTest.scala
index 883b1c7..bb24455 100644
--- core/src/test/scala/chompdb/server/NodeProtocolTest.scala
+++ core/src/test/scala/chompdb/server/NodeProtocolTest.scala
@@ -53,6 +53,7 @@ class NodeProtocolTest extends WordSpec with ShouldMatchers {
         override val replicationBeforeVersionUpgrade = 1
         override val maxVersions = 3
         override val maxDownloadRetries = 3
+        override val databaseDownloadRetryDelay = 10.millisecond
         override val executor = mock(classOf[ScheduledExecutorService])
         override val databaseUpdateFreq = 1.minute
         override val nodesAliveFreq = 1.minute
diff --git integration/src/main/scala/chompdb/integration/DatabaseServer.scala integration/src/main/scala/chompdb/integration/DatabaseServer.scala
index 7fd83e3..1b845c0 100644
--- integration/src/main/scala/chompdb/integration/DatabaseServer.scala
+++ integration/src/main/scala/chompdb/integration/DatabaseServer.scala
@@ -27,10 +27,11 @@ trait DatabaseServer extends Chomp {
 
   val params: Params
 
-  override val databaseUpdateFreq  = 1.minute
-  override val nodesAliveFreq      = 1.minute
-  override val nodesContentFreq    = 1.minute
-  override val servingVersionsFreq = 1.minute
+  override val databaseUpdateFreq         = 1.minute
+  override val databaseDownloadRetryDelay = 5.millis
+  override val nodesAliveFreq             = 1.minute
+  override val nodesContentFreq           = 1.minute
+  override val servingVersionsFreq        = 1.minute
 
   override def serializeMapReduce[T, U](mapReduce: MapReduce[T, U]): String = "mapReduce"
 
